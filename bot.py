from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
    ContextTypes,
    ConversationHandler,
)
from datetime import datetime
import os
import asyncio
import threading
import http.server
import socketserver

# üîß –£–∫–∞–∂–∏ —Å–≤–æ–π Telegram user ID:
ADMIN_ID = 166773394

# –≠—Ç–∞–ø—ã –¥–∏–∞–ª–æ–≥–∞
TICKETS, CASH, CARD, RETURNS_COUNT, RETURNS_SUM, TOTAL_TICKETS = range(6)

# –ö–Ω–æ–ø–∫–∞ "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –æ—Ç—á—ë—Ç"
async def restart_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    msg = await query.message.chat.send_message("–°–∫–æ–ª—å–∫–æ –±–∏–ª–µ—Ç–æ–≤ –∑–∞ —Å–º–µ–Ω—É –ø–æ —Ç–≤–æ–µ–π –∫–æ–º–ø–∞–Ω–∏–∏?")
    context.user_data.setdefault("to_delete", []).append(msg.message_id)
    return TICKETS

# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è ‚Äî –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å –∏ –∑–∞–ø–æ–º–Ω–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
async def ask_and_remember(update, context, text, next_state):
    msg = await update.message.reply_text(text)
    context.user_data.setdefault("to_delete", []).append(msg.message_id)
    return next_state

# –°—Ç–∞—Ä—Ç –∫–æ–º–∞–Ω–¥—ã
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    return await ask_and_remember(update, context, "–°–∫–æ–ª—å–∫–æ –±–∏–ª–µ—Ç–æ–≤ –∑–∞ —Å–º–µ–Ω—É –ø–æ —Ç–≤–æ–µ–π –∫–æ–º–ø–∞–Ω–∏–∏?", TICKETS)

# –í–≤–æ–¥ –±–∏–ª–µ—Ç–æ–≤
async def tickets(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message.text.isdigit():
        return await ask_and_remember(update, context, "–í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.", TICKETS)
    context.user_data["tickets"] = int(update.message.text)
    return await ask_and_remember(update, context, "–í–≤–µ–¥–∏—Ç–µ –≤—ã—Ä—É—á–∫—É –Ω–∞–ª–∏—á–Ω—ã–º–∏:", CASH)

# –í–≤–æ–¥ –Ω–∞–ª–∏—á–Ω—ã—Ö
async def cash(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message.text.isdigit():
        return await ask_and_remember(update, context, "–í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.", CASH)
    context.user_data["cash"] = int(update.message.text)
    return await ask_and_remember(update, context, "–í–≤–µ–¥–∏—Ç–µ –≤—ã—Ä—É—á–∫—É –ø–æ –±–µ–∑–Ω–∞–ª—É:", CARD)

# –í–≤–æ–¥ –±–µ–∑–Ω–∞–ª–∞
async def card(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message.text.isdigit():
        return await ask_and_remember(update, context, "–í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.", CARD)
    context.user_data["card"] = int(update.message.text)
    return await ask_and_remember(update, context, "–°–∫–æ–ª—å–∫–æ –±—ã–ª–æ –≤–æ–∑–≤—Ä–∞—Ç–æ–≤?", RETURNS_COUNT)

# –í–≤–æ–¥ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –≤–æ–∑–≤—Ä–∞—Ç–æ–≤
async def returns_count(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message.text.isdigit():
        return await ask_and_remember(update, context, "–í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.", RETURNS_COUNT)
    context.user_data["returns_count"] = int(update.message.text)
    return await ask_and_remember(update, context, "–í–≤–µ–¥–∏—Ç–µ –æ–±—â—É—é —Å—É–º–º—É –≤–æ–∑–≤—Ä–∞—Ç–æ–≤:", RETURNS_SUM)

# –í–≤–æ–¥ —Å—É–º–º—ã –≤–æ–∑–≤—Ä–∞—Ç–æ–≤
async def returns_sum(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message.text.isdigit():
        return await ask_and_remember(update, context, "–í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.", RETURNS_SUM)
    context.user_data["returns_sum"] = int(update.message.text)
    return await ask_and_remember(update, context, "–°–∫–æ–ª—å–∫–æ –±–∏–ª–µ—Ç–æ–≤ –ø—Ä–æ–¥–∞–Ω–æ —Ç–æ–±–æ–π –ø–æ –≤—Å–µ–º –∫–æ–º–ø–∞–Ω–∏—è–º?", TOTAL_TICKETS)

# –í–≤–æ–¥ –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –±–∏–ª–µ—Ç–æ–≤
async def total_tickets(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message.text.isdigit():
        return await ask_and_remember(update, context, "–í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.", TOTAL_TICKETS)
    context.user_data["total_tickets"] = int(update.message.text)

    total = context.user_data["cash"] + context.user_data["card"]
    date_str = datetime.now().strftime("%d.%m.%Y")
    summary = (
        f"–°–ø–∞—Å–∏–±–æ!\n"
        f"üìÖ –î–∞—Ç–∞: {date_str}\n"
        f"üéü –ë–∏–ª–µ—Ç—ã (—Ç–≤–æ—è –∫–æ–º–ø–∞–Ω–∏—è): {context.user_data['tickets']}\n"
        f"üíµ –ù–∞–ª–∏—á–Ω—ã–µ: {context.user_data['cash']} ‚ÇΩ\n"
        f"üí≥ –ë–µ–∑–Ω–∞–ª: {context.user_data['card']} ‚ÇΩ\n"
        f"‚Ü©Ô∏è –í–æ–∑–≤—Ä–∞—Ç–æ–≤: {context.user_data['returns_count']} –Ω–∞ —Å—É–º–º—É {context.user_data['returns_sum']} ‚ÇΩ\n"
        f"üéü –í—Å–µ–≥–æ –±–∏–ª–µ—Ç–æ–≤ (–≤—Å–µ –∫–æ–º–ø–∞–Ω–∏–∏): {context.user_data['total_tickets']}\n"
        f"üßæ –ò—Ç–æ–≥–æ: {total} ‚ÇΩ"
    )

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –æ—Ç—á—ë—Ç", callback_data="restart")]
    ])

    await update.message.reply_text(summary, reply_markup=keyboard)

    if update.effective_user.id != ADMIN_ID:
        await context.bot.send_message(
            chat_id=ADMIN_ID,
            text=f"üì• –ù–æ–≤—ã–π –æ—Ç—á—ë—Ç –æ—Ç @{update.effective_user.username or '–±–µ–∑ username'}:\n\n{summary}"
        )

    to_delete = context.user_data.get("to_delete", [])
    for msg_id in to_delete:
        try:
            await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=msg_id)
        except Exception:
            pass

    context.user_data.clear()
    return ConversationHandler.END

# –û—Ç–º–µ–Ω–∞
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")
    context.user_data.clear()
    return ConversationHandler.END

# üîå –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è Render (–æ–±—Ö–æ–¥ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –æ—Ç–∫—Ä—ã—Ç—å HTTP-–ø–æ—Ä—Ç)
def keep_port_open():
    port = int(os.environ.get("PORT", 10000))
    handler = http.server.SimpleHTTPRequestHandler
    with socketserver.TCPServer(("", port), handler) as httpd:
        print(f"‚öôÔ∏è  –ó–∞–≥–ª—É—à–∫–∞ HTTP-—Å–µ—Ä–≤–µ—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞ –Ω–∞ –ø–æ—Ä—Ç—É {port}")
        httpd.serve_forever()

if __name__ == '__main__':
    threading.Thread(target=keep_port_open, daemon=True).start()

    app = ApplicationBuilder().token(os.environ["TELEGRAM_TOKEN"]).build()

    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            CallbackQueryHandler(restart_callback, pattern="^restart$")
        ],
        states={
            TICKETS: [MessageHandler(filters.TEXT & ~filters.COMMAND, tickets)],
            CASH: [MessageHandler(filters.TEXT & ~filters.COMMAND, cash)],
            CARD: [MessageHandler(filters.TEXT & ~filters.COMMAND, card)],
            RETURNS_COUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, returns_count)],
            RETURNS_SUM: [MessageHandler(filters.TEXT & ~filters.COMMAND, returns_sum)],
            TOTAL_TICKETS: [MessageHandler(filters.TEXT & ~filters.COMMAND, total_tickets)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    app.add_handler(conv_handler)
    app.run_polling()
